/**
\defgroup demos Demos
\ingroup demos
@{

\par
- <a href="RigidBodyPlanning_8cpp_source.html"><strong>Rigid body planning</strong></a> <a href="RigidBodyPlanning_8py_source.html"><strong>[Python version]</strong></a>.
This demo is essentially the same example described in the first tutorial. It illustrates how to use the main classes.
- <a href="StateSampling_8cpp_source.html"><strong>State sampling</strong></a> <a href="StateSampling_8py_source.html"><strong>[Python version]</strong></a>. This is the demo program used in the last beginner tutorial.
- <a href="RigidBodyPlanningWithControls_8cpp_source.html"><strong>Rigid body planning with controls</strong></a> <a href="RigidBodyPlanningWithControls_8py_source.html"><strong>[Python version]</strong></a>.
This demo shows how to perform planning under differential constraints for a simple car-like vehicle.
- <a href="RigidBodyPlanningWithIntegrationAndControls_8cpp_source.html"><strong>Rigid body planning with integration and controls. </strong></a>
This example extends the previous example by showing how one can plan for systems of ordinary differential equations in a generic way. This example uses simple Euler integration. For higher accuracy it is recommended to use higher-order methods. Other libraries such as the <a href="http://www.gnu.org/software/gsl/">GNU Scientific Library</a> or <a href="http://headmyshoulder.github.com/odeint-v2/">Boost.Numeric.Odeint</a> can be used for this purpose.
- <a href="RigidBodyPlanningWithODESolverAndControls_8cpp_source.html"><strong>Rigid body planning with ODESolver and controls. </strong></a>
This example compares and contrasts the previous demo of planning with integration and planning using the ODESolver class, which wraps around <a href="http://headmyshoulder.github.com/odeint-v2/">Boost.Numeric.Odeint</a>.  Code showing the same model being planned with a user-implemented numerical integration technique as well as the ODESolver is presented.
- <a href="RigidBodyPlanningWithIK_8cpp_source.html"><strong>Rigid body planning with an Inverse Kinematics solver generating goal states in a separate thread. </strong></a>
This demo shows off two neat features of OMPL: a genetic algorithm-based Inverse Kinematics solver and a lazy goal state sampler. In a separate thread goal states are computed by the IK solver. While solving a motion planning problem, the planning algorithms select a random goal state from the ones computed so far.
- <a href="ODERigidBodyPlanning_8cpp_source.html"><strong>Rigid body planning using the Open Dynamics Engine (ODE). </strong></a>
When ODE is installed, OMPL will compile an extension that makes is easier to use ODE for forward propagation of models of motion. In this example, a box is pushed around in the plane from a start position to a goal position.
- <a href="GeometricCarPlanning_8cpp_source.html"><strong>Planning for Dubins and Reeds-Shepp cars. </strong></a>
This demo illustrates the use of the ompl::base::DubinsStateSpace and ompl::base::ReedsSheppStateSpace. The demo can solve two simple planning problems, print trajectories from the origin to a user-specified state, or print a discretized distance field.
.

@}

*/
